---
references:
- id: sawaya_flit_2017
  type: paper-conference
  author:
  - family: Sawaya
    given: G.
  - family: Bentley
    given: M.
  - family: Briggs
    given: I.
  - family: Gopalakrishnan
    given: G.
  - family: Ahn
    given: D. H.
  issued:
  - year: '2017'
  title: 'FLiT: Cross-platform floating-point result-consistency tester and workload'
  title-short: FLiT
  container-title: IEEE international symposium on workload characterization
  publisher-place: Seattle
  abstract: 'Result reproducibility in societally important simulations faces the
    grave risk of becoming voided when code is ported across hardware platforms or
    optimized using different compiler flags. There are currently no available tools
    that can help a programmer assess the extent of such non-portability through systematic
    testing. In this work, we offer a novel testing framework called FLiT that comes
    with a large collection of predesigned tests, and also test automation facilities,
    including Makefile generation, distribution of the tests to CPU/GPU platforms,
    and result amalgamation/query supported through SQL queries. We also develop an
    intuitive 2D “heat-map” style visualization of how much a given compiler and its
    flag(s) can affect a given program. FLiT is an easy-to-use and community extensible
    framework, allowing the tool to grow in versatility as more tests are contributed
    and support for newer compilers is added. Our results span three architectures
    (including GPUs), four popular compilers, and dozens of compiler optimization
    flags. We demonstrate the power of FLiT’s test automation and result analysis/visualization
    support. For the first time, for example, FLiT’s systematic exploration was able
    to discover the following results: (1) when seeking higher performance through
    flags, compilers may apply unsafe algebraic simplifications, yielding up *six*
    or more different answers in some test cases; (2) compilers are inconsistent in
    the number of answer variants; in this ranking, Intel’s icpc comes first, followed
    by GCC, then Clang, and finally NVCC.'
  PDF: 'sawaya_flit_2017.pdf'
  citation: |
   @inproceedings{7069300,
                  Author = {J. Protze and S. Atzeni and D. H. Ahn and
                            M. Schulz and G. Gopalakrishnan and M. S.
                            M{\"u}ller and I. Laguna and
                            Z. Rakamari{\'c} and G. L. Lee},
                  Booktitle = {2014 {LLVM} {C}ompiler {I}nfrastructure
                               in {HPC}},
                  Doi = {10.1109/LLVM-HPC.2014.7},
                  Month = {Nov},
                  Pages = {40-47},
                  Title = {{T}owards {P}roviding {L}ow-{O}verhead {D}ata
                           {R}ace {D}etection for {L}arge {O}penMP
                           {A}pplications},
                  Year = {2014},}
...
